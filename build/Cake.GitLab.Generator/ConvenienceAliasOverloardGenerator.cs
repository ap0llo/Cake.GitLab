using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Cake.GitLab.Generator;

/// <summary>
/// Source generator that generates additional overloads for all Cake aliases in the GitLabAliases class
/// </summary>
/// <remarks>
/// By default, Cake aliases are extension methods or ICakeContext and the GitLabAliases require a <c>GitLabConnection</c> to be passed in.
/// To make it more convenient to call the GitLab aliases from a Cake script, the <c>connection</c> parameter may be omitted of the cotext implements <c>IGitLabConnectionCakeContext</c>.
/// <para>
/// To avoid having to define aditionall overloads manually, this generator generates an extension method on <c>IGitLabConnectionCakeContext</c> for each alias method and call the original alaias with the conenction retrieed from the <c>IGitLabConnectionCakeContext</c> context.
/// </para>
/// </remarks>
[Generator]
public class ConvenienceAliasOverloardGenerator : ISourceGenerator
{
    private class Symbols
    {
        /// <summary>
        /// Gets the symbol for the <c>Cake.GitLab.GitLabAliases</c> type
        /// </summary>
        public INamedTypeSymbol GitLabAliases { get; set; } = null!;

        /// <summary>
        /// Gets the symbol for the <c>Cake.GitLab.GitLabConnection</c> type
        /// </summary>
        public INamedTypeSymbol GitLabConnection { get; set; } = null!;

        /// <summary>
        /// Gets the symbol for the <c>Cake.GitLab.IGitLabConnectionCakeContext</c> type
        /// </summary>
        public INamedTypeSymbol GitLabConnectionCakeContext { get; set; } = null!;

        /// <summary>
        /// Gets the symbol for the <c>Cake.Core.ICakeContext</c> type
        /// </summary>
        public INamedTypeSymbol CakeContext { get; set; } = null!;

        /// <summary>
        /// Gets the symbol for the <c>System.Threading.Tasks.Task</c> type
        /// </summary>
        public INamedTypeSymbol SystemThreadingTasksTask { get; set; } = null!;

        public static Symbols? TryGet(GeneratorExecutionContext generatorContext)
        {
            // Find required type symbols
            if (!TryGetSymbolByMetadataName(generatorContext, "Cake.GitLab.GitLabAliases", out var gitLabAliasesSymbol) ||
               !TryGetSymbolByMetadataName(generatorContext, "Cake.GitLab.GitLabConnection", out var gitlabConnectionSymbol) ||
               !TryGetSymbolByMetadataName(generatorContext, "Cake.GitLab.IGitLabConnectionCakeContext", out var gitlabConnectionCakeContextSymbol) ||
               !TryGetSymbolByMetadataName(generatorContext, "Cake.Core.ICakeContext", out var cakeContextSymbol) ||
               !TryGetSymbolByMetadataName(generatorContext, "System.Threading.Tasks.Task", out var systemThreadingTasksTaskSymbol))
            {
                return null;
            }

            return new Symbols()
            {
                GitLabAliases = gitLabAliasesSymbol!,
                GitLabConnection = gitlabConnectionSymbol!,
                GitLabConnectionCakeContext = gitlabConnectionCakeContextSymbol!,
                CakeContext = cakeContextSymbol!,
                SystemThreadingTasksTask = systemThreadingTasksTaskSymbol!
            };
        }

        private static bool TryGetSymbolByMetadataName(GeneratorExecutionContext generatorContext, string metadataName, out INamedTypeSymbol? symbol)
        {
            symbol = generatorContext.Compilation.GetTypeByMetadataName(metadataName);

            if (symbol is null)
            {
                generatorContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.RequiredTypeNotFound, location: null, metadataName));
                return false;
            }
            else
            {
                return true;
            }
        }
    }


    private class SourceCodeBuilder
    {
        private StringBuilder m_StringBuilder = new();
        private int m_Indent = 0;

        public SourceCodeBuilder()
        {
            m_StringBuilder.AppendLine("// <auto-generated/>");
            m_StringBuilder.AppendLine();
        }


        public void Append(string value) => m_StringBuilder.Append(value);

        public void Append(ITypeSymbol symbol) => m_StringBuilder.Append(GetFullName(symbol));

        public void AppendLine(string value) => m_StringBuilder.AppendLine(value);

        public void AppendLine() => m_StringBuilder.AppendLine();

        public void AppendFileScopedNamespace(INamespaceSymbol @namespace)
        {
            m_StringBuilder.Append($"namespace ");
            m_StringBuilder.Append(GetFullName(@namespace));
            m_StringBuilder.Append(";");
            m_StringBuilder.AppendLine();

            m_StringBuilder.AppendLine();
        }

        public void BeginLine()
        {
            for (int i = 0; i < m_Indent; i++)
            {
                m_StringBuilder.Append(s_IndentChars);
            }
        }

        public void EndLine()
        {
            m_StringBuilder.AppendLine();
        }

        public void BeginBlock()
        {
            for (int i = 0; i < m_Indent; i++)
            {
                m_StringBuilder.Append(s_IndentChars);
            }
            m_StringBuilder.AppendLine("{");

            m_Indent += 1;
        }

        public void EndBlock()
        {
            m_Indent -= 1;

            for (int i = 0; i < m_Indent; i++)
            {
                m_StringBuilder.Append(s_IndentChars);
            }
            m_StringBuilder.AppendLine("}");

        }

        public override string ToString() => m_StringBuilder.ToString();

        private static string GetFullName(INamespaceOrTypeSymbol symbol)
        {
            string name;
            if (symbol.ContainingNamespace is not null && GetFullName(symbol.ContainingNamespace) is string parentName && !String.IsNullOrEmpty(parentName))
            {
                name = $"{parentName}.{symbol.Name}";
            }
            else
            {
                name = symbol.Name;
            }

            if (symbol is INamedTypeSymbol namedTypeSymbol)
            {
                if (namedTypeSymbol.Arity > 0)
                {
                    name += $"<{String.Join(",", namedTypeSymbol.TypeArguments.Select(GetFullName))}>";
                }
            }

            return name;
        }

    }

    private class Context : IDisposable
    {
        public GeneratorExecutionContext GeneratorContext { get; }

        public Symbols Symbols { get; }

        public SourceCodeBuilder Output { get; } = new();


        private Context(GeneratorExecutionContext generatorContext, Symbols symbols)
        {
            GeneratorContext = generatorContext;
            Symbols = symbols;
        }


        public void Dispose()
        {
            GeneratorContext.AddSource($"{Symbols.GitLabAliases.Name}.g.cs", Output.ToString());
        }


        public static Context? TryCreate(GeneratorExecutionContext generatorContext)
        {
            // Find required type symbols
            var symbols = Symbols.TryGet(generatorContext);
            if (symbols is null)
            {
                return null;
            }

            return new Context(generatorContext, symbols);
        }
    }

    private const string s_IndentChars = "    ";

    public void Initialize(GeneratorInitializationContext context)
    { }

    public void Execute(GeneratorExecutionContext generatorContext)
    {
        using var context = Context.TryCreate(generatorContext);

        if (context is null)
        {
            return;
        }

        var aliases = context.Symbols.GitLabAliases
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(method =>
                method.DeclaredAccessibility == Accessibility.Public &&
                method.IsStatic &&
                method.Parameters.Length >= 2 &&
                SymbolEqualityComparer.Default.Equals(method.Parameters[0].Type, context.Symbols.CakeContext) &&
                SymbolEqualityComparer.Default.Equals(method.Parameters[1].Type, context.Symbols.GitLabConnection)
            );

        if (!aliases.Any())
        {
            return;
        }


        context.Output.AppendFileScopedNamespace(context.Symbols.GitLabAliases.ContainingNamespace);

        context.Output.BeginLine();
        context.Output.Append($"public static partial class {context.Symbols.GitLabAliases.Name}");
        context.Output.EndLine();

        context.Output.BeginBlock();
        {
            foreach (var alias in aliases)
            {
                // TODO: Generate /// documentation comments based on documentation of original alias

                context.Output.BeginLine();
                context.Output.Append("[global::Cake.Core.Annotations.CakeMethodAlias]");
                context.Output.EndLine();

                context.Output.BeginLine();
                context.Output.Append("public static ");


                // Return Type
                if (alias.IsAsync)
                {
                    context.Output.Append("async ");
                }

                if (alias.ReturnsVoid)
                {
                    context.Output.Append("void ");
                }
                else
                {
                    context.Output.Append("global::");
                    context.Output.Append(alias.ReturnType);
                    context.Output.Append(" ");
                }

                // Method Name
                context.Output.Append(alias.Name);

                // Parameters (first parameter of type IGitLabConnectionCakeContext replaces the first two parameters of the original declaration)
                context.Output.Append("(this global::");
                context.Output.Append(context.Symbols.GitLabConnectionCakeContext);
                context.Output.Append(" context");

                // Add remaining parameters unchanged
                foreach (var parameter in alias.Parameters.Skip(2))
                {
                    context.Output.Append(", ");
                    context.Output.Append("global::");
                    context.Output.Append(parameter.Type);
                    context.Output.Append(" ");
                    context.Output.Append("@");
                    context.Output.Append(parameter.Name);
                }
                context.Output.Append(")");
                context.Output.EndLine();

                context.Output.BeginBlock();
                {
                    context.Output.BeginLine();

                    // add "return" if alias returns a value, otherwise omit it
                    if (!alias.ReturnsVoid && !(alias.IsAsync && SymbolEqualityComparer.Default.Equals(alias.ReturnType, context.Symbols.SystemThreadingTasksTask)))
                    {
                        context.Output.Append("return ");
                    }

                    // Add "await" is alias is asnc
                    if (alias.IsAsync)
                    {
                        context.Output.Append("await ");
                    }

                    // Call original alias
                    context.Output.Append("global::");
                    context.Output.Append(context.Symbols.GitLabAliases);
                    context.Output.Append(".");
                    context.Output.Append(alias.Name);

                    // Pass first two parameters (context and the connection provided by the context)
                    context.Output.Append("(context, context.Connection");

                    // Pass remaining parameter
                    foreach (var parameter in alias.Parameters.Skip(2))
                    {
                        context.Output.Append(", ");
                        context.Output.Append("@");
                        context.Output.Append(parameter.Name);
                    }
                    context.Output.Append(");");

                    context.Output.EndLine();
                }
                context.Output.EndBlock();

                // For readability, add empty line between methods
                context.Output.AppendLine();

            }

        }
        context.Output.EndBlock();
    }
}
